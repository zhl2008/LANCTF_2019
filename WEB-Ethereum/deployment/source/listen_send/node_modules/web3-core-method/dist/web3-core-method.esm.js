import EventEmitter from 'eventemitter3';
import isString from 'lodash/isString';
import cloneDeep from 'lodash/cloneDeep';
import { PromiEvent } from 'web3-core-promievent';
import { SubscriptionsFactory } from 'web3-core-subscriptions';
import { formatters } from 'web3-core-helpers';
import * as Utils from 'web3-utils';
import isFunction from 'lodash/isFunction';

class TransactionConfirmationWorkflow {
  constructor(transactionReceiptValidator, newHeadsWatcher, getTransactionReceiptMethod) {
    this.transactionReceiptValidator = transactionReceiptValidator;
    this.newHeadsWatcher = newHeadsWatcher;
    this.timeoutCounter = 0;
    this.confirmationsCounter = 0;
    this.getTransactionReceiptMethod = getTransactionReceiptMethod;
  }
  execute(method, moduleInstance, transactionHash, promiEvent) {
    this.getTransactionReceiptMethod.parameters = [transactionHash];
    this.getTransactionReceiptMethod.execute(moduleInstance).then(receipt => {
      if (receipt && receipt.blockHash) {
        const validationResult = this.transactionReceiptValidator.validate(receipt, method);
        if (validationResult === true) {
          this.handleSuccessState(receipt, method, promiEvent);
          return;
        }
        this.handleErrorState(validationResult, method, promiEvent);
        return;
      }
      this.newHeadsWatcher.watch(moduleInstance).on('newHead', () => {
        this.timeoutCounter++;
        if (!this.isTimeoutTimeExceeded(moduleInstance, this.newHeadsWatcher.isPolling)) {
          this.getTransactionReceiptMethod.execute(moduleInstance).then(receipt => {
            if (receipt && receipt.blockHash) {
              const validationResult = this.transactionReceiptValidator.validate(receipt, method);
              if (validationResult === true) {
                this.confirmationsCounter++;
                promiEvent.emit('confirmation', this.confirmationsCounter, receipt);
                if (this.isConfirmed(moduleInstance)) {
                  this.handleSuccessState(receipt, method, promiEvent);
                }
                return;
              }
              this.handleErrorState(validationResult, method, promiEvent);
            }
          });
          return;
        }
        let error = new Error(`Transaction was not mined within ${moduleInstance.transactionBlockTimeout} blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!`);
        if (this.newHeadsWatcher.isPolling) {
          error = new Error(`Transaction was not mined within ${moduleInstance.transactionPollingTimeout} seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!`);
        }
        this.handleErrorState(error, method, promiEvent);
      });
    });
  }
  isConfirmed(moduleInstance) {
    return this.confirmationsCounter === moduleInstance.transactionConfirmationBlocks;
  }
  isTimeoutTimeExceeded(moduleInstance, watcherIsPolling) {
    let timeout = moduleInstance.transactionBlockTimeout;
    if (watcherIsPolling) {
      timeout = moduleInstance.transactionPollingTimeout;
    }
    return this.timeoutCounter > timeout;
  }
  handleSuccessState(receipt, method, promiEvent) {
    this.timeoutCounter = 0;
    this.confirmationsCounter = 0;
    this.newHeadsWatcher.stop();
    if (method.constructor.name === 'ContractDeployMethod') {
      if (method.callback) {
        method.callback(false, receipt);
      }
      promiEvent.resolve(method.afterExecution(receipt));
      promiEvent.emit('receipt', receipt);
      promiEvent.removeAllListeners();
      return;
    }
    const mappedReceipt = method.afterExecution(receipt);
    if (method.callback) {
      method.callback(false, mappedReceipt);
    }
    promiEvent.resolve(mappedReceipt);
    promiEvent.emit('receipt', mappedReceipt);
    promiEvent.removeAllListeners();
  }
  handleErrorState(error, method, promiEvent) {
    this.timeoutCounter = 0;
    this.confirmationsCounter = 0;
    this.newHeadsWatcher.stop();
    if (method.callback) {
      method.callback(error, null);
    }
    promiEvent.reject(error);
    promiEvent.emit('error', error);
    promiEvent.removeAllListeners();
  }
}

class TransactionReceiptValidator {
  validate(receipt, method) {
    const receiptJSON = JSON.stringify(receipt, null, 2);
    if (!this.isValidGasUsage(receipt, method)) {
      return new Error(`Transaction ran out of gas. Please provide more gas:\n${receiptJSON}`);
    }
    if (!this.isValidReceiptStatus(receipt)) {
      return new Error(`Transaction has been reverted by the EVM:\n${receiptJSON}`);
    }
    return true;
  }
  isValidReceiptStatus(receipt) {
    return receipt.status === true || typeof receipt.status === 'undefined' || receipt.status === null;
  }
  isValidGasUsage(receipt, method) {
    return !receipt.outOfGas && method.utils.hexToNumber(method.parameters[0].gas) !== receipt.gasUsed;
  }
}

class NewHeadsWatcher extends EventEmitter {
  constructor(subscriptionsFactory) {
    super();
    this.subscriptionsFactory = subscriptionsFactory;
    this.confirmationInterval = null;
    this.confirmationSubscription = null;
    this.isPolling = false;
  }
  watch(moduleInstance) {
    if (moduleInstance.currentProvider.constructor.name !== 'HttpProvider') {
      this.confirmationSubscription = this.subscriptionsFactory.createNewHeadsSubscription(moduleInstance).subscribe(() => {
        this.emit('newHead');
      });
      return this;
    }
    this.isPolling = true;
    this.confirmationInterval = setInterval(() => {
      this.emit('newHead');
    }, 1000);
    return this;
  }
  stop() {
    if (this.confirmationSubscription) {
      this.confirmationSubscription.unsubscribe();
    }
    if (this.confirmationInterval) {
      clearInterval(this.confirmationInterval);
    }
    this.removeAllListeners('newHead');
  }
}

class MethodProxy {
  constructor(target, methodFactory) {
    return new Proxy(target, {
      get: (target, name) => {
        if (methodFactory.hasMethod(name)) {
          if (typeof target[name] !== 'undefined') {
            throw new TypeError(`Duplicated method ${name}. This method is defined as RPC call and as Object method.`);
          }
          const method = methodFactory.createMethod(name);
          function anonymousFunction() {
            method.arguments = arguments;
            if (method.Type === 'CALL') {
              return method.execute(target);
            }
            return method.execute(target, new PromiEvent());
          }
          anonymousFunction.method = method;
          anonymousFunction.request = function () {
            method.arguments = arguments;
            return method;
          };
          return anonymousFunction;
        }
        return target[name];
      }
    });
  }
}

class AbstractMethod {
  constructor(rpcMethod, parametersAmount, utils, formatters$$1) {
    this.utils = utils;
    this.formatters = formatters$$1;
    this.promiEvent = new PromiEvent();
    this._arguments = {
      parameters: []
    };
    this._rpcMethod = rpcMethod;
    this._parametersAmount = parametersAmount;
  }
  beforeExecution(moduleInstance) {}
  afterExecution(response) {
    return response;
  }
  execute(moduleInstance) {}
  set rpcMethod(value) {
    this._rpcMethod = value;
  }
  get rpcMethod() {
    return this._rpcMethod;
  }
  set parametersAmount(value) {
    this._parametersAmount = value;
  }
  get parametersAmount() {
    return this._parametersAmount;
  }
  get parameters() {
    return this._arguments.parameters;
  }
  set parameters(value) {
    this._arguments.parameters = value;
  }
  get callback() {
    return this._arguments.callback;
  }
  set callback(value) {
    this._arguments.callback = value;
  }
  set arguments(args) {
    let parameters = cloneDeep([...args]);
    let callback = null;
    if (parameters.length > this.parametersAmount) {
      if (!isFunction(parameters[parameters.length - 1])) {
        throw new TypeError("The latest parameter should be a function otherwise it can't be used as callback");
      }
      callback = parameters.pop();
    }
    this._arguments = {
      callback,
      parameters
    };
  }
  get arguments() {
    return this._arguments;
  }
  isHash(parameter) {
    return isString(parameter) && parameter.indexOf('0x') === 0;
  }
}

class AbstractCallMethod extends AbstractMethod {
  constructor(rpcMethod, parametersAmount, utils, formatters$$1) {
    super(rpcMethod, parametersAmount, utils, formatters$$1);
  }
  static get Type() {
    return 'CALL';
  }
  async execute(moduleInstance) {
    this.beforeExecution(moduleInstance);
    if (this.parameters.length !== this.parametersAmount) {
      throw new Error(`Invalid Arguments length: expected: ${this.parametersAmount}, given: ${this.parameters.length}`);
    }
    try {
      let response = await moduleInstance.currentProvider.send(this.rpcMethod, this.parameters);
      if (response) {
        response = this.afterExecution(response);
      }
      if (this.callback) {
        this.callback(false, response);
      }
      return response;
    } catch (error) {
      if (this.callback) {
        this.callback(error, null);
      }
      throw error;
    }
  }
}

class GetTransactionReceiptMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_getTransactionReceipt', 1, utils, formatters$$1);
  }
  afterExecution(response) {
    if (response !== null) {
      return this.formatters.outputTransactionReceiptFormatter(response);
    }
    return response;
  }
}

class AbstractSendMethod extends AbstractMethod {
  constructor(rpcMethod, parametersAmount, utils, formatters$$1, transactionConfirmationWorkflow) {
    super(rpcMethod, parametersAmount, utils, formatters$$1);
    this.transactionConfirmationWorkflow = transactionConfirmationWorkflow;
  }
  static get Type() {
    return 'SEND';
  }
  execute(moduleInstance, promiEvent) {
    this.beforeExecution(moduleInstance);
    if (this.parameters.length !== this.parametersAmount) {
      throw new Error(`Invalid Arguments length: expected: ${this.parametersAmount}, given: ${this.parameters.length}`);
    }
    moduleInstance.currentProvider.send(this.rpcMethod, this.parameters).then(response => {
      this.transactionConfirmationWorkflow.execute(this, moduleInstance, response, promiEvent);
      if (this.callback) {
        this.callback(false, response);
      }
      promiEvent.emit('transactionHash', response);
    }).catch(error => {
      if (this.callback) {
        this.callback(error, null);
      }
      promiEvent.reject(error);
      promiEvent.emit('error', error);
      promiEvent.removeAllListeners();
    });
    return promiEvent;
  }
}

class SendRawTransactionMethod extends AbstractSendMethod {
  constructor(utils, formatters$$1, transactionConfirmationWorkflow) {
    super('eth_sendRawTransaction', 1, utils, formatters$$1, transactionConfirmationWorkflow);
  }
}

class ModuleFactory {
  constructor(subscriptionsFactory, utils, formatters$$1) {
    this.subscriptionsFactory = subscriptionsFactory;
    this.formatters = formatters$$1;
    this.utils = utils;
  }
  createMethodProxy(target, methodFactory) {
    return new MethodProxy(target, methodFactory);
  }
  createTransactionConfirmationWorkflow() {
    return new TransactionConfirmationWorkflow(this.createTransactionReceiptValidator(), this.createNewHeadsWatcher(), new GetTransactionReceiptMethod(this.utils, this.formatters));
  }
  createTransactionReceiptValidator() {
    return new TransactionReceiptValidator();
  }
  createNewHeadsWatcher() {
    return new NewHeadsWatcher(this.subscriptionsFactory);
  }
  createSendRawTransactionMethod() {
    return new SendRawTransactionMethod(this.utils, this.formatters, this.createTransactionConfirmationWorkflow());
  }
}

class GetTransactionCountMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_getTransactionCount', 2, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputAddressFormatter(this.parameters[0]);
    if (isFunction(this.parameters[1])) {
      this.callback = this.parameters[1];
      this.parameters[1] = moduleInstance.defaultBlock;
    }
    this.parameters[1] = this.formatters.inputDefaultBlockNumberFormatter(this.parameters[1], moduleInstance);
  }
  afterExecution(response) {
    return this.utils.hexToNumber(response);
  }
}

class ChainIdMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_chainId', 0, utils, formatters$$1);
  }
  afterExecution(response) {
    return this.utils.hexToNumber(response);
  }
}

class AbstractMethodFactory {
  constructor(methodModuleFactory, utils, formatters$$1) {
    this.methodModuleFactory = methodModuleFactory;
    this.utils = utils;
    this.formatters = formatters$$1;
    this._methods = null;
  }
  get methods() {
    if (this._methods) {
      return this._methods;
    }
    throw new Error('No methods defined for MethodFactory!');
  }
  set methods(value) {
    this._methods = value;
  }
  hasMethod(name) {
    return typeof this.methods[name] !== 'undefined';
  }
  createMethod(name) {
    const method = this.methods[name];
    switch (method.Type) {
      case 'CALL':
        return new method(this.utils, this.formatters);
      case 'SEND':
        if (method.name === 'SendTransactionMethod') {
          const transactionConfirmationWorkflow = this.methodModuleFactory.createTransactionConfirmationWorkflow();
          return new method(this.utils, this.formatters, transactionConfirmationWorkflow, new SendRawTransactionMethod(this.utils, this.formatters, transactionConfirmationWorkflow), new ChainIdMethod(this.utils, this.formatters), new GetTransactionCountMethod(this.utils, this.formatters));
        }
        return new method(this.utils, this.formatters, this.methodModuleFactory.createTransactionConfirmationWorkflow());
    }
  }
}

class GetProtocolVersionMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_protocolVersion', 0, utils, formatters$$1);
  }
}

class VersionMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('net_version', 0, utils, formatters$$1);
  }
  afterExecution(response) {
    return this.utils.hexToNumber(response);
  }
}

class ListeningMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('net_listening', 0, utils, formatters$$1);
  }
}

class PeerCountMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('net_peerCount', 0, utils, formatters$$1);
  }
  afterExecution(response) {
    return this.utils.hexToNumber(response);
  }
}

class GetNodeInfoMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('web3_clientVersion', 0, utils, formatters$$1);
  }
}

class GetCoinbaseMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_coinbase', 0, utils, formatters$$1);
  }
}

class IsMiningMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_mining', 0, utils, formatters$$1);
  }
}

class GetHashrateMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_hashrate', 0, utils, formatters$$1);
  }
  afterExecution(response) {
    return this.utils.hexToNumber(response);
  }
}

class IsSyncingMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_syncing', 0, utils, formatters$$1);
  }
  afterExecution(response) {
    if (typeof response !== 'boolean') {
      return this.formatters.outputSyncingFormatter(response);
    }
    return response;
  }
}

class GetGasPriceMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_gasPrice', 0, utils, formatters$$1);
  }
  afterExecution(response) {
    return this.formatters.outputBigNumberFormatter(response);
  }
}

class SubmitWorkMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_submitWork', 3, utils, formatters$$1);
  }
}

class GetWorkMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_getWork', 0, utils, formatters$$1);
  }
}

class GetAccountsMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_accounts', 0, utils, formatters$$1);
  }
  afterExecution(response) {
    return response.map(responseItem => {
      return this.utils.toChecksumAddress(responseItem);
    });
  }
}

class GetBalanceMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_getBalance', 2, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputAddressFormatter(this.parameters[0]);
    if (isFunction(this.parameters[1])) {
      this.callback = this.parameters[1];
      this.parameters[1] = moduleInstance.defaultBlock;
    }
    this.parameters[1] = this.formatters.inputDefaultBlockNumberFormatter(this.parameters[1], moduleInstance);
  }
  afterExecution(response) {
    return this.formatters.outputBigNumberFormatter(response);
  }
}

class RequestAccountsMethod extends AbstractCallMethod {
  constructor() {
    super('eth_requestAccounts', 0, null, null);
  }
}

class GetBlockNumberMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_blockNumber', 0, utils, formatters$$1);
  }
  afterExecution(response) {
    return this.utils.hexToNumber(response);
  }
}

class GetBlockMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_getBlockByNumber', 2, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    if (this.isHash(this.parameters[0])) {
      this.rpcMethod = 'eth_getBlockByHash';
    }
    this.parameters[0] = this.formatters.inputBlockNumberFormatter(this.parameters[0]);
    if (isFunction(this.parameters[1])) {
      this.callback = this.parameters[1];
      this.parameters[1] = false;
    } else {
      this.parameters[1] = !!this.parameters[1];
    }
  }
  afterExecution(response) {
    return this.formatters.outputBlockFormatter(response);
  }
}

class GetUncleMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_getUncleByBlockNumberAndIndex', 2, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    if (this.isHash(this.parameters[0])) {
      this.rpcMethod = 'eth_getUncleByBlockHashAndIndex';
    }
    this.parameters[0] = this.formatters.inputBlockNumberFormatter(this.parameters[0]);
    this.parameters[1] = this.utils.numberToHex(this.parameters[1]);
  }
  afterExecution(response) {
    return this.formatters.outputBlockFormatter(response);
  }
}

class GetBlockTransactionCountMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_getBlockTransactionCountByNumber', 1, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    if (this.isHash(this.parameters[0])) {
      this.rpcMethod = 'eth_getBlockTransactionCountByHash';
    }
    this.parameters[0] = this.formatters.inputBlockNumberFormatter(this.parameters[0]);
  }
  afterExecution(response) {
    return this.utils.hexToNumber(response);
  }
}

class GetBlockUncleCountMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_getUncleCountByBlockNumber', 1, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    if (this.isHash(this.parameters[0])) {
      this.rpcMethod = 'eth_getUncleCountByBlockHash';
    }
    this.parameters[0] = this.formatters.inputBlockNumberFormatter(this.parameters[0]);
  }
  afterExecution(response) {
    return this.utils.hexToNumber(response);
  }
}

class GetTransactionMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_getTransactionByHash', 1, utils, formatters$$1);
  }
  afterExecution(response) {
    return this.formatters.outputTransactionFormatter(response);
  }
}

class GetTransactionFromBlockMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_getTransactionByBlockNumberAndIndex', 2, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    if (this.isHash(this.parameters[0])) {
      this.rpcMethod = 'eth_getTransactionByBlockHashAndIndex';
    }
    this.parameters[0] = this.formatters.inputBlockNumberFormatter(this.parameters[0]);
    this.parameters[1] = this.utils.numberToHex(this.parameters[1]);
  }
  afterExecution(response) {
    return this.formatters.outputTransactionFormatter(response);
  }
}

class SignTransactionMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_signTransaction', 1, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputTransactionFormatter(this.parameters[0], moduleInstance);
  }
}

class SendTransactionMethod extends AbstractSendMethod {
  constructor(utils, formatters$$1, transactionConfirmationWorkflow, sendRawTransactionMethod, chainIdMethod, getTransactionCountMethod) {
    super('eth_sendTransaction', 1, utils, formatters$$1, transactionConfirmationWorkflow);
    this.sendRawTransactionMethod = sendRawTransactionMethod;
    this.chainIdMethod = chainIdMethod;
    this.getTransactionCountMethod = getTransactionCountMethod;
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputTransactionFormatter(this.parameters[0], moduleInstance);
  }
  execute(moduleInstance, promiEvent) {
    if (!this.parameters[0].gas && moduleInstance.defaultGas) {
      this.parameters[0]['gas'] = moduleInstance.defaultGas;
    }
    if (!this.parameters[0].gasPrice) {
      if (!moduleInstance.defaultGasPrice) {
        moduleInstance.currentProvider.send('eth_gasPrice', []).then(gasPrice => {
          this.parameters[0].gasPrice = gasPrice;
          this.execute(moduleInstance, promiEvent);
        });
        return promiEvent;
      }
      this.parameters[0]['gasPrice'] = moduleInstance.defaultGasPrice;
    }
    if (this.hasAccounts(moduleInstance) && this.isDefaultSigner(moduleInstance)) {
      if (moduleInstance.accounts.wallet[this.parameters[0].from]) {
        this.sendRawTransaction(moduleInstance.accounts.wallet[this.parameters[0].from].privateKey, promiEvent, moduleInstance).catch(error => {
          if (this.callback) {
            this.callback(error, null);
          }
          promiEvent.reject(error);
          promiEvent.emit('error', error);
          promiEvent.removeAllListeners();
        });
        return promiEvent;
      }
    }
    if (this.hasCustomSigner(moduleInstance)) {
      this.sendRawTransaction(null, promiEvent, moduleInstance).catch(error => {
        if (this.callback) {
          this.callback(error, null);
        }
        promiEvent.reject(error);
        promiEvent.emit('error', error);
        promiEvent.removeAllListeners();
      });
      return promiEvent;
    }
    super.execute(moduleInstance, promiEvent);
    return promiEvent;
  }
  async sendRawTransaction(privateKey, promiEvent, moduleInstance) {
    if (!this.parameters[0].chainId) {
      this.parameters[0].chainId = await this.chainIdMethod.execute(moduleInstance);
    }
    if (!this.parameters[0].nonce && this.parameters[0].nonce !== 0) {
      this.getTransactionCountMethod.parameters = [this.parameters[0].from];
      this.parameters[0].nonce = await this.getTransactionCountMethod.execute(moduleInstance);
    }
    const response = await moduleInstance.transactionSigner.sign(this.parameters[0], privateKey);
    this.sendRawTransactionMethod.parameters = [response.rawTransaction];
    this.sendRawTransactionMethod.callback = this.callback;
    this.sendRawTransactionMethod.execute(moduleInstance, promiEvent);
  }
  isDefaultSigner(moduleInstance) {
    return moduleInstance.transactionSigner.constructor.name === 'TransactionSigner';
  }
  hasAccounts(moduleInstance) {
    return moduleInstance.accounts && moduleInstance.accounts.accountsIndex > 0;
  }
  hasCustomSigner(moduleInstance) {
    return moduleInstance.transactionSigner.constructor.name !== 'TransactionSigner';
  }
}

class GetCodeMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_getCode', 2, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputAddressFormatter(this.parameters[0]);
    if (isFunction(this.parameters[1])) {
      this.callback = this.parameters[1];
      this.parameters[1] = moduleInstance.defaultBlock;
    }
    this.parameters[1] = this.formatters.inputDefaultBlockNumberFormatter(this.parameters[1], moduleInstance);
  }
}

class SignMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_sign', 2, utils, formatters$$1);
  }
  execute(moduleInstance) {
    if (this.hasAccount(moduleInstance)) {
      return this.signLocally(moduleInstance);
    }
    return super.execute(moduleInstance);
  }
  async signLocally(moduleInstance) {
    try {
      this.beforeExecution(moduleInstance);
      let signedMessage = moduleInstance.accounts.sign(this.parameters[0], moduleInstance.accounts.wallet[this.parameters[1]].address);
      if (this.callback) {
        this.callback(false, signedMessage);
      }
      return signedMessage;
    } catch (error) {
      if (this.callback) {
        this.callback(error, null);
      }
      throw error;
    }
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputSignFormatter(this.parameters[0]);
    this.parameters[1] = this.formatters.inputAddressFormatter(this.parameters[1]);
  }
  hasAccount(moduleInstance) {
    return moduleInstance.accounts && moduleInstance.accounts.accountsIndex > 0 && moduleInstance.accounts.wallet[this.parameters[1]];
  }
}

class CallMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_call', 2, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputCallFormatter(this.parameters[0], moduleInstance);
    if (isFunction(this.parameters[1])) {
      this.callback = this.parameters[1];
      this.parameters[1] = moduleInstance.defaultBlock;
    }
    this.parameters[1] = this.formatters.inputDefaultBlockNumberFormatter(this.parameters[1], moduleInstance);
  }
}

class GetStorageAtMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_getStorageAt', 3, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputAddressFormatter(this.parameters[0]);
    this.parameters[1] = this.utils.numberToHex(this.parameters[1]);
    if (isFunction(this.parameters[2])) {
      this.callback = this.parameters[2];
      this.parameters[2] = moduleInstance.defaultBlock;
    }
    this.parameters[2] = this.formatters.inputDefaultBlockNumberFormatter(this.parameters[2], moduleInstance);
  }
}

class EstimateGasMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_estimateGas', 1, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputCallFormatter(this.parameters[0], moduleInstance);
  }
  afterExecution(response) {
    return this.utils.hexToNumber(response);
  }
}

class GetPastLogsMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('eth_getLogs', 1, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputLogFormatter(this.parameters[0]);
  }
  afterExecution(response) {
    return response.map(responseItem => {
      return this.formatters.outputLogFormatter(responseItem);
    });
  }
}

class EcRecoverMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('personal_ecRecover', 3, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputSignFormatter(this.parameters[0]);
  }
}

class ImportRawKeyMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('personal_importRawKey', 2, utils, formatters$$1);
  }
}

class ListAccountsMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('personal_listAccounts', 0, utils, formatters$$1);
  }
  afterExecution(response) {
    return response.map(responseItem => {
      return this.utils.toChecksumAddress(responseItem);
    });
  }
}

class LockAccountMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('personal_lockAccount', 1, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputAddressFormatter(this.parameters[0]);
  }
}

class NewAccountMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('personal_newAccount', 1, utils, formatters$$1);
  }
  afterExecution(response) {
    return this.utils.toChecksumAddress(response);
  }
}

class PersonalSendTransactionMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('personal_sendTransaction', 2, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputTransactionFormatter(this.parameters[0], moduleInstance);
  }
}

class PersonalSignMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('personal_sign', 3, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputSignFormatter(this.parameters[0]);
    this.parameters[1] = this.formatters.inputAddressFormatter(this.parameters[1]);
  }
}

class PersonalSignTransactionMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('personal_signTransaction', 2, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputTransactionFormatter(this.parameters[0], moduleInstance);
  }
}

class UnlockAccountMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('personal_unlockAccount', 3, utils, formatters$$1);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputAddressFormatter(this.parameters[0]);
  }
}

class AddPrivateKeyMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_addPrivateKey', 1, utils, formatters$$1);
  }
}

class AddSymKeyMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_addSymKey', 1, utils, formatters$$1);
  }
}

class DeleteKeyPairMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_deleteKeyPair', 1, utils, formatters$$1);
  }
}

class DeleteMessageFilterMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_deleteMessageFilter', 1, utils, formatters$$1);
  }
}

class DeleteSymKeyMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_deleteSymKey', 1, utils, formatters$$1);
  }
}

class GenerateSymKeyFromPasswordMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_generateSymKeyFromPassword', 1, utils, formatters$$1);
  }
}

class GetFilterMessagesMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_getFilterMessages', 1, utils, formatters$$1);
  }
}

class GetInfoMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_info', 0, utils, formatters$$1);
  }
}

class GetPrivateKeyMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_getPrivateKey', 1, utils, formatters$$1);
  }
}

class GetPublicKeyMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_getPublicKey', 1, utils, formatters$$1);
  }
}

class GetSymKeyMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_getSymKey', 1, utils, formatters$$1);
  }
}

class HasKeyPairMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_hasKeyPair', 1, utils, formatters$$1);
  }
}

class HasSymKeyMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_hasSymKey', 1, utils, formatters$$1);
  }
}

class MarkTrustedPeerMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_markTrustedPeer', 1, utils, formatters$$1);
  }
}

class NewKeyPairMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_newKeyPair', 1, utils, formatters$$1);
  }
}

class NewMessageFilterMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_newMessageFilter', 1, utils, formatters$$1);
  }
}

class NewSymKeyMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_newSymKey', 0, utils, formatters$$1);
  }
}

class PostMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_post', 1, utils, formatters$$1);
  }
}

class SetMaxMessageSizeMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_setMaxMessageSize', 1, utils, formatters$$1);
  }
}

class SetMinPoWMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_setMinPoW', 1, utils, formatters$$1);
  }
}

class ShhVersionMethod extends AbstractCallMethod {
  constructor(utils, formatters$$1) {
    super('shh_version', 0, utils, formatters$$1);
  }
}

const MethodModuleFactory = () => {
  return new ModuleFactory(new SubscriptionsFactory(), Utils, formatters);
};

export { MethodModuleFactory, AbstractMethod, AbstractMethodFactory, GetProtocolVersionMethod, VersionMethod, ListeningMethod, PeerCountMethod, ChainIdMethod, GetNodeInfoMethod, GetCoinbaseMethod, IsMiningMethod, GetHashrateMethod, IsSyncingMethod, GetGasPriceMethod, SubmitWorkMethod, GetWorkMethod, GetAccountsMethod, GetBalanceMethod, GetTransactionCountMethod, RequestAccountsMethod, GetBlockNumberMethod, GetBlockMethod, GetUncleMethod, GetBlockTransactionCountMethod, GetBlockUncleCountMethod, GetTransactionMethod, GetTransactionFromBlockMethod, GetTransactionReceiptMethod as GetTransactionReceipt, SendRawTransactionMethod, SignTransactionMethod, SendTransactionMethod, GetCodeMethod, SignMethod, CallMethod, GetStorageAtMethod, EstimateGasMethod, GetPastLogsMethod, EcRecoverMethod, ImportRawKeyMethod, ListAccountsMethod, LockAccountMethod, NewAccountMethod, PersonalSendTransactionMethod, PersonalSignMethod, PersonalSignTransactionMethod, UnlockAccountMethod, AddPrivateKeyMethod, AddSymKeyMethod, DeleteKeyPairMethod, DeleteMessageFilterMethod, DeleteSymKeyMethod, GenerateSymKeyFromPasswordMethod, GetFilterMessagesMethod, GetInfoMethod, GetPrivateKeyMethod, GetPublicKeyMethod, GetSymKeyMethod, HasKeyPairMethod, HasSymKeyMethod, MarkTrustedPeerMethod, NewKeyPairMethod, NewMessageFilterMethod, NewSymKeyMethod, PostMethod, SetMaxMessageSizeMethod, SetMinPoWMethod, ShhVersionMethod };
